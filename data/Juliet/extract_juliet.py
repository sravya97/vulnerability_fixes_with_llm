import os
import re
import pandas as pd

def get_juliet_chat_data(input_path, output_path, dir="."):
    root_directory = input_path

    dir_items = os.listdir(root_directory)
    subdirectories = [item for item in dir_items if os.path.isdir(os.path.join(root_directory, item))]
    error_types = []
    error_numbers = []

    for sub_dir in subdirectories:
        split_sub_dir = sub_dir.split('_')
        error_type = ' '.join([i for i in split_sub_dir if 'CWE' not in i])
        error_numbers.append(split_sub_dir[0])
        error_types.append(error_type)


    # Iterate through each file in the sub directory
    # Iterate through each c and cpp
    # Extract the bad data function
    # Label it with its associated label

    # Necessary Regex
    comment_pattern = r'(/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/)|(//.*)'
    bad_code_pattern = r'#ifndef OMITBAD(.*?)#endif /\* OMITBAD \*/'
    good_code_pattern = r'#ifndef OMITGOOD(.*?)#endif /\* OMITGOOD \*/'

    bad = []
    cwe = []
    cwe_label = []
    good = []
    file_paths = []

    for i, value in enumerate(subdirectories):
        current_dir = root_directory + value
        
        if dir not in current_dir:
            continue
        else:
            print(current_dir)
            
        filenames = []
        for filename in os.listdir(current_dir):
            if os.path.isdir(os.path.join(current_dir, filename)):
                for sub_filename in os.listdir(os.path.join(current_dir, filename)):
                    filepath = os.path.join(current_dir, filename, sub_filename)
                    
                    filenames.append(filepath)
            else:
                filepath = os.path.join(current_dir, filename)
                filenames.append(filepath)
                    
        for filename in filenames:
                    
            if filename.endswith(".c") or filename.endswith(".cpp"):
                file_path = filename

                with open(file_path, 'r') as file:
                    function_name = filename.replace('.c', '')
                    function_name = function_name.replace('.cpp','')
                    file_contents = file.read()
                   
                    bad_matches = re.findall(bad_code_pattern, file_contents, re.DOTALL)
                    good_matches = re.findall(good_code_pattern, file_contents, re.DOTALL)

                    if bad_matches:
                        bad_function = bad_matches[0]
                    else:
                        continue

                    if good_matches:
                        good_function = good_matches[0]
                    else:
                        continue

                    bad_function = re.sub(comment_pattern, '', bad_function)
                    # DONE: Remove the error name from the function
                    bad_function = bad_function.replace(function_name, 'generic_function')
                    bad_function = bad_function.replace('bad', '')

                    good_function = re.sub(comment_pattern, '', good_function)
                    good_function = good_function.replace(function_name, 'generic_function')
                    # TODO: Parse the separate solutions - How tho?
                    good_function = good_function.replace('good', '')

                    bad.append(bad_function)
                    cwe_label.append(error_types[i])
                    cwe.append(error_numbers[i])
                    good.append(good_function)
                    file_paths.append(file_path)
                    
    
    print("filepaths: " + str(len(file_paths)))
    print("Bad: " + str(len(bad)))
    print("cwe: " + str(len(cwe)))
    print("label: " + str(len(cwe_label)))
    print("good: " + str(len(good)))
    df_correction = pd.DataFrame({'filepath': file_paths,'bad_function': bad, 'cwe': cwe, 'cwe_label': cwe_label, 'Patch': good})
    
    df_correction.to_csv(output_path, index=False)


get_juliet_chat_data("datasets/C/testcases/", 
                     "datasets/danger_fun_data.csv", 
                     dir="CWE676_Use_of_Potentially_Dangerous_Function")